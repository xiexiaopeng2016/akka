---
project.description: What is an Actor and sending messages between independent units of computation in Akka.
---
# 什么是Actor?

关于 @ref:[Actor Systems](actor-systems.md) 的前一节说明了actor如何形成层次结构，并且是构建应用程序时最小的单元。本节单独讨论这样一个actor，解释您在实现它时遇到的概念。想要更深入地了解所有细节，请参考 @ref:[Actor介绍](../typed/actors.md)。

[Actor Model](http://en.wikipedia.org/wiki/Actor_model) 是Hewitt，Bishop和Steiger在1973年定义的，是一个计算模型，它准确地表达了分布式计算的含义。处理单元—Actor—只能通过交换消息进行通信，而在接收到消息之后，Actor可以执行以下三个基本操作：

  1. 向它知道的Actor发送有限数量的消息
  2. 创建有限数量的新Actor
  3. 指定要应用于下一条消息的行为

actor是 @ref:[状态](#state), @ref:[行为](#behavior), @ref:[邮箱](#mailbox), @ref:[子Actor](#child-actors)和 @ref:[监督策略](#supervisor-strategy)的容器。所有这些都封装在一个 @ref:[Actor引用](#actor-reference) 背后。一个值得注意的方面是actor具有明确的生命周期，当不再引用它们时，它们不会自动销毁。创建完一个后，您有责任确保它最终也将终止，这也使您可以控制 @ref:[当一个Actor终止时](#when-an-actor-terminates)时如何释放资源。

<a id="actor-reference"></a>
## Actor引用

如下所述，为了从actor模型中受益，需要从外部屏蔽actor对象。因此，使用actor引用将actor呈现给外部，actor引用是可以自由传递且不受限制的对象。这种分为内部和外部对象的功能使所有所需操作的透明性得以实现：重新启动actor，无需在其他地方更新引用；将实际的actor对象放置在远程主机上；向运行在完全不同的位置的actor发送消息。但最重要的方面是，不可能从查看actor的内部并从外部获取其状态，除非参与者不明智地发布了自己的信息。

Actor引用是参数化的，只有特定类型的消息才能发送给它们。

<a id="state"></a>
## 状态

Actor对象通常将包含一些变量，这些变量反映Actor可能处于的状态。这可以是显式状态机，或者它也可以是计数器，侦听器集合，未决的请求等。这些数据是使一个演员有价值的东西，必须保护它们免受其他actor的腐蚀。好消息是，Akka actor从概念上讲都有各自的轻量级线程，该线程与系统的其余部分完全隔离。这意味着不必使用锁来同步访问，您可以编写自己的actor代码，而不必担心并发性。

在后台，Akka将在一组实际线程上运行一组actor，其中通常有许多actor共享一个线程，而对一个actor的后续调用最终可能会在不同的线程上进行处理。Akka确保此实现细节不会影响处理actor状态的单线程。

因为内部状态对actor的操作至关重要，所以不一致的状态是致命的。因此，当actor失败并由其上级重新启动时，状态将从零开始创建，就像第一次创建actor时一样。这是为了使系统能够自我修复。

另外，可以通过持久化接收到的消息，将参与者的状态自动恢复到重启之前的状态，且重启后重播(查看 @ref:[Event Sourcing](../typed/persistence.md))。

<a id="behavior"></a>
## 行为

每次处理消息时，都会将其与actor的当前行为进行匹配。行为指的是一个函数，它定义了在那个时间点对消息的响应所采取的操作，例如，如果客户端被授权，则转发一个请求，否则拒绝它。这种行为可能会随着时间的推移而改变，例如，由于不同的客户端随着时间的推移而获得授权，或者由于actor可能进入“停止服务”模式，并再后面回来。这些更改可以通过将它们编码到从行为逻辑中读取的状态变量中来实现，或者函数本身也可以在运行时换出，方法返回一个不同的行为，用于下一条消息。然而，在构造actor对象期间定义的初始行为是特殊的，因为重新启动actor会将其行为重置为初始行为。

可以将消息发送到一个 @ref:[actor引用](#actor-reference)，在这个表面的背后，有一个接收消息并对其进行操作的行为。actor引用和行为之间的绑定可能会随着时间的推移而改变，但这在外部是不可见的。

Actor引用已参数化，并且只能将指定类型的消息发送给它们。创建一个actor引用(及其Actor)时，必须在actor引用与其类型参数之间建立关联。为此，每个行为还可以用它能够处理的消息类型参数化。
由于行为可以在actor引用表面背后改变，因此指定下一个行为是受约束的操作：继任者必须处理与其前任相同类型的消息。为了不使引用此Actor的actor引用无效，这是必需的。

这可以实现的是，无论何时将消息发送给Actor，我们都可以静态地确保消息的类型是Actor声明要处理的类型 - 我们可以避免发送完全没有意义的信息的错误。但是，我们不能静态地确保的是，当接收到我们的消息时，actor引用背后的行为将处于给定的状态。根本原因是actor引用和行为之间的关联是动态的运行时属性，编译器在编译源代码时无法知道。

这与具有内部变量的普通Java对象相同：在编译程序时，我们不知道它们的值是什么，并且如果方法调用的结果取决于这些变量，那么结果在一定程度上是不确定的 — 我们只能确定返回的值是给定类型的。

一个Actor命令的回复消息类型由消息中包含的reply-to的Actor引用类型描述的。这允许根据它们的类型来描述一个对话：答复的类型将为A，但它也可能包含B类型的地址，然后允许其它actor通过向这个新的actor引用发送一个B类型的消息来继续对话。虽然我们不能静态地表示一个actor的“当前”状态，但是我们可以表示两个actor之间协议的当前状态，因为它是由接收或发送的最后一个消息类型给出的。

<a id="mailbox"></a>
## 邮箱

一个actor的目的是处理消息，这些消息是从其他actor(或actor系统外部)发送给actor的。

连接发送者和接收者的部分是actor的邮箱：每个actor都恰好只有一个邮箱，所有发送者都将他们的消息入队邮箱。入队按发送操作的时间顺序进行，这意味着从不同actor发送的消息在运行时可能没有定义的顺序，这是由于actor跨线程分布的明显随机性造成的。另一方面，从同一个actor向同一个目标发送多个消息将使它们以相同顺序入队。

有不同的邮箱实现可供选择，默认的是FIFO：actor处理的消息的顺序与入队的顺序相匹配。这通常是一个很好的默认设置，但是应用程序可能需要将某些消息优先于其他消息。在这种情况下，一个优先级邮箱将不总是入队在最后面，而是入队在邮件优先级给定的位置，该位置甚至可能在最前面。使用这种队列时，消息的处理顺序自然将由队列的算法定义，通常不是FIFO。

Akka与某些其他actor模型实现不同的一个重要特性是，当前行为必须始终处理下一条出队的消息，无需扫描邮箱以查找下一条匹配的消息。处理一条消息失败通常被视为故障，除非此行为被覆盖。

<a id="child-actors"></a>
## 子Actor

每个actor都可能是一个父actor：如果它创建了用于委派子任务的子actor，它会自动监督它们。子actor列表在actor的上下文中维护，actor可以访问它。对列表的修改是通过生成或停止子actor来完成的，这些操作将立即反映出来。实际的创建和终止操作以异步方式在幕后进行，因此它们不会“阻塞”它们的父actor。

<a id="supervisor-strategy"></a>
## 监督策略

actor的最后一部分是处理意外异常的策略 - 故障。故障处理由Akka透明地完成，对每个故障应用 @ref:[故障容错](../typed/fault-tolerance.md)中描述的一个策略。

<a id="when-an-actor-terminates"></a>
## 当一个actor终止时

一旦actor终止，例如，失败的方式不是通过重新启动来处理，而是自动停止或被其上级停止，它将释放其资源，将所有剩余的消息从其邮箱中抽出，放入系统的“死信邮箱”，该邮箱将把它们作为死信转发给事件流。然后在actor引用中使用一个系统邮箱替换邮箱，将所有新消息作为死信重定向到事件流。不过，这是在尽最大努力的基础上完成的，因此不要依赖它来构建“保证交付”。
