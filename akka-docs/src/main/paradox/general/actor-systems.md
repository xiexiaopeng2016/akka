---
project.description: The Akka ActorSystem.
---
<a id="actor-systems"></a>
# Actor系统

Actor是封装状态和行为的对象，它们仅通过交换放置在接收者邮箱中的消息进行通信。从某种意义上说，actor是面向对象编程最严格的形式，但把他们看成人更好：在用actor建模一个解决方案时，设想一组人并为他们分配子任务，将他们的功能安排到一个组织结构并考虑如何升级故障(所有这些都是不实际与人打交道的好处，这意味着我们不必担心自己的情感状态或道德问题)。然后，结果可以作为构建软件实现的思想框架。

@@@ note

一个ActorSystem是一个重量级的结构，它将分配1…N个线程，因此请为每个逻辑应用程序创建一个。

@@@

<a id="hierarchical-structure"></a>
## 层次结构

就像在一个经济组织中一样，actor自然会形成层次结构。一个actor，它负责监督程序中某个功能，可能希望将其任务分解成更小、更易于管理的部分。为此，它启动了子actor。

actor系统的典型特征是任务被分解和委托，直到它们变得足够小，可以单独处理。这样做时，不仅任务本身的结构非常清晰，还可以对作为结果的actor进行推理，根据应该处理哪些消息，他们应该如何正常反应，以及应该如何处理失败。

将此与分层软件设计进行比较，它很容易演变为防御性编程，目的是不泄漏任何故障：如果将问题传达给正确的人，则比将一切都“掩盖”的情况下，可以找到更好的解决方案。

现在，设计这样一个系统的困难在于如何决定如何组织工作。没有单独的最佳解决方案，但是有一些准则可能会有所帮助：

 * 如果一个actor传递非常重要的数据(即如果可以避免，其状态不会丢失)，这个actor应该将任何可能危险的子任务分配给子actor，并适当地处理这些子actor的故障。根据请求的性质，最好为每个请求创建一个新的子actor，从而简化用于收集答复的状态管理。这就是Erlang中的“错误内核模式”。
 * 如果一个actor要依靠另一个actor来履行职责，则应监视另一个actor的生命，并在收到终止通知后采取行动。
 * 如果一个actor有多个职责，则通常可以将每个职责推入一个单独的子actor中，以使逻辑和状态变得更简单。

<a id="configuration-container"></a>
## 配置容器

actor系统作为一个协作的actor集合，是管理共享设施的自然单元，比如调度服务、配置、日志记录等。
具有不同配置的多个actor系统可以在同一个JVM中共存，不会出现问题，在Akka内部没有全局共享状态。然而，最常见的场景是每个JVM只涉及一个actor系统。

将此与Actor系统之间之间的透明通信结合在一起 — 在一个节点内或跨网络连接 — actor系统非常适合构建分布式应用程序。

<a id="actor-best-practices"></a>
## Actor最佳实践

 1. actor应该像好同事一样：有效地完成工作，而不会不必要地打扰其他人，并且避免浪费资源。翻译成编程，这意味着以事件驱动的方式处理事件并生成响应(或更多请求)。actor不应阻塞(例如，占用线程时被动地等待)某个外部实体 — 那些可能是锁，网络套接字等 — 除非不可避免；在后一种情况下，请参见下文。
 2. 不要在actor之间传递可变的对象。为了确保这一点，首选不可变消息。如果通过将actor的可变状态暴露于外部而破坏了actor的封装，那么您将回到正常的Java并发领域，并具有所有缺点。
 3. Actor被作为行为和状态的容器，接受这一点意味着不要经常在信息中传递行为(使用Scala闭包可能很诱人)。其中一个风险是意外地在actor之间共享可变状态，遗憾的是，这种对actor模型的违反破坏了所有的属性，而这些属性使actor中的编程成为一种很好的体验。
 4. actor系统的顶级actor是你的Error Kernel的最内层部分，它应该仅负责启动应用程序的各个子系统，并且本身不包含太多逻辑，更喜欢真正的分层系统。这在处理错误方面有好处(同时考虑配置的粒度和性能)，同时也减轻了监督者actor的压力，如果过度使用，这将是一个争议点。

<a id="what-you-should-not-concern-yourself-with"></a>
## 你不该关心的事

一个actor系统管理资源，它被配置为用于运行它所包含的actor。在一个这样的系统中可能有数百万个actor，毕竟，我们通常认为它们是丰富的，每个实例的开销大约只有300字节。当然，在大型系统中处理消息的确切顺序是应用程序作者无法控制的，但这也不是必须的。后退一步，放松一下，Akka做引擎盖下的苦活。

<a id="terminating-actorsystem"></a>
## 终止ActorSystem

当您知道应用程序已完成所有操作后，您可以停止用户监督者actor或调用`ActorSystem`的`terminate`方法。这将运行 @ref:[`CoordinatedShutdown`](../coordinated-shutdown.md)停止所有正在运行的actor。

如果要在终止`ActorSystem`时执行一些操作，请查看 @ref:[`CoordinatedShutdown`](../coordinated-shutdown.md)。
