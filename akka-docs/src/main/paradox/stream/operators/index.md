<!-- DO NOT EDIT DIRECTLY: This file is generated by `project/StreamOperatorsIndexGenerator`. See CONTRIBUTING.md for details. -->
# Operators

## Source operators

These built-in sources are available from @scala[`akka.stream.scaladsl.Source`] @java[`akka.stream.javadsl.Source`]:

| |Operator|Description|
|--|--|--|
|Source|<a name="actorref"></a>@ref[actorRef](Source/actorRef.md)|物化一个`ActorRef`; 发送消息给它，它将在流上发射这些消息。|
|Source|<a name="actorrefwithbackpressure"></a>@ref[actorRefWithBackpressure](Source/actorRefWithBackpressure.md)|物化一个`ActorRef`；发送消息给它将在流上发射这些消息。发送消息后，源确认接收，以提供来自源的背压。|
|Source|<a name="assourcewithcontext"></a>@ref[asSourceWithContext](Source/asSourceWithContext.md)|将一个`Source`转换为一个`SourceWithContext`，这可以在整个流中传播一个上下文每伴随每个元素。|
|Source|<a name="assubscriber"></a>@ref[asSubscriber](Source/asSubscriber.md)|与Reactive Streams集成，物化到一个`org.reactivestreams.Subscriber`里面。|
|Source|<a name="combine"></a>@ref[combine](Source/combine.md)|使用给定的策略，比如`merge`或`concat`，将多个源合并为一个源。|
|Source|<a name="completionstage"></a>@ref[completionStage](Source/completionStage.md)|当`CompletionStage`完成并且有需求时，发送它的单个值。|
|Source|<a name="completionstagesource"></a>@ref[completionStageSource](Source/completionStageSource.md)|流动一个异步源的元素，一旦它给定的 *completion* 运算符完成|
|Source|<a name="cycle"></a>@ref[cycle](Source/cycle.md)|Stream iterator in cycled manner.|
|Source|<a name="empty"></a>@ref[empty](Source/empty.md)|立即完成，而不发出任何元素。|
|Source|<a name="failed"></a>@ref[failed](Source/failed.md)|使用用户指定的异常直接失败。|
|Source|<a name="from"></a>@ref[@scala[apply]@java[from]](Source/from.md)|流动 @scala[`immutable.Seq`]@java[`Iterable`] 的值。|
|Source|<a name="fromcompletionstage"></a>@ref[fromCompletionStage](Source/fromCompletionStage.md)|`fromCompletionStage` 在2.6.0中已弃用，请使用 `Source.completionStage`|
|Source|<a name="fromfuture"></a>@ref[fromFuture](Source/fromFuture.md)|`fromFuture` 在2.6.0中已弃用，请用 `Source.future` 代替。|
|Source|<a name="fromfuturesource"></a>@ref[fromFutureSource](Source/fromFutureSource.md)|`fromFutureSource` 在2.6.0中已弃用，请用 `Source.futureSource` 代替。|
|Source|<a name="fromiterator"></a>@ref[fromIterator](Source/fromIterator.md)|从一个`Iterator`中流动值，当有需求时请求下一个值。|
|Source|<a name="frompublisher"></a>@ref[fromPublisher](Source/fromPublisher.md)|与Reactive Streams集成，订阅了一个`org.reactivestreams.Publisher`。|
|Source|<a name="fromsourcecompletionstage"></a>@ref[fromSourceCompletionStage](Source/fromSourceCompletionStage.md)|`fromSourceCompletionStage` 在2.6.0中已弃用，请用 `Source.completionStageSource` 代替.|
|Source|<a name="future"></a>@ref[future](Source/future.md)|当`Future`完成并且有需求时，发送它的单个值。|
|Source|<a name="futuresource"></a>@ref[futureSource](Source/futureSource.md)|流动给定的future源的元素，一旦它成功完成。|
|Source|<a name="lazily"></a>@ref[lazily](Source/lazily.md)|`lazily` 在2.6.0中已弃用，请用 `Source.lazySource` 代替。|
|Source|<a name="lazilyasync"></a>@ref[lazilyAsync](Source/lazilyAsync.md)|`lazilyAsync` 在2.6.0中已弃用，请用 `Source.lazyFutureSource` 代替。|
|Source|<a name="lazycompletionstage"></a>@ref[lazyCompletionStage](Source/lazyCompletionStage.md)|将一个单个元素的源的future的创建推迟到有需求的时候。|
|Source|<a name="lazycompletionstagesource"></a>@ref[lazyCompletionStageSource](Source/lazyCompletionStageSource.md)|将一个future源的创建推迟到有需求的时候。|
|Source|<a name="lazyfuture"></a>@ref[lazyFuture](Source/lazyFuture.md)|将一个单个元素源的future的创建推迟到有需求时。|
|Source|<a name="lazyfuturesource"></a>@ref[lazyFutureSource](Source/lazyFutureSource.md)|将一个`Source`的创造和物化推迟到有需求的时候。|
|Source|<a name="lazysingle"></a>@ref[lazySingle](Source/lazySingle.md)|将一个单个元素的源的创建延迟到有需求时。|
|Source|<a name="lazysource"></a>@ref[lazySource](Source/lazySource.md)|将一个`Source`的创建和物化推迟到有需求的时候。|
|Source|<a name="maybe"></a>@ref[maybe](Source/maybe.md)|创建一个源，它一旦已物化的 @scala[`Promise`]@java[`CompletableFuture`] 带有一个值完成，就发出。|
|Source|<a name="queue"></a>@ref[queue](Source/queue.md)|物化一个`SourceQueue`，那些元素可被推到其上，用于从源发出。|
|Source|<a name="range"></a>@ref[range](Source/range.md)|发出一个范围内的每个整数，具有一个可选项，用于采用大于1的步长。|
|Source|<a name="repeat"></a>@ref[repeat](Source/repeat.md)|重复流动一个对象|
|Source|<a name="single"></a>@ref[single](Source/single.md)|流动一个单个对象|
|Source|<a name="tick"></a>@ref[tick](Source/tick.md)|一个任意对象的一个定期的重复。|
|Source|<a name="unfold"></a>@ref[unfold](Source/unfold.md)|流动一个函数的结果，只要它返回一个 @scala[`Some`]@java[`Optional`]。|
|Source|<a name="unfoldasync"></a>@ref[unfoldAsync](Source/unfoldAsync.md)|与`unfold`类似，但是fold函数返回一个 @scala[`Future`]@java[`CompletionStage`]。|
|Source|<a name="unfoldresource"></a>@ref[unfoldResource](Source/unfoldResource.md)|将任何可以打开、查询下一个元素(以阻塞方式)和使用三个不同的函数关闭的资源包装到一个源中。|
|Source|<a name="unfoldresourceasync"></a>@ref[unfoldResourceAsync](Source/unfoldResourceAsync.md)|将任何可以打开、查询下一个元素(以阻塞方式)和使用三个不同的函数关闭的资源包装到一个源中。|
|Source|<a name="zipn"></a>@ref[zipN](Source/zipN.md)|将多个流的元素组合成一个序列流。|
|Source|<a name="zipwithn"></a>@ref[zipWithN](Source/zipWithN.md)|使用一个组合器函数将多个流的元素组合成一个序列流。|

## Sink operators

These built-in sinks are available from @scala[`akka.stream.scaladsl.Sink`] @java[`akka.stream.javadsl.Sink`]:


| |Operator|Description|
|--|--|--|
|Sink|<a name="actorref"></a>@ref[actorRef](Sink/actorRef.md)|将元素从流发送到一个`ActorRef`。|
|Sink|<a name="actorrefwithbackpressure"></a>@ref[actorRefWithBackpressure](Sink/actorRefWithBackpressure.md)|将元素从流发送到一个`ActorRef`，它必须在完成一个消息后确认接收，以向接收器提供背压。|
|Sink|<a name="aspublisher"></a>@ref[asPublisher](Sink/asPublisher.md)|与响应流集成，物化到一个`org.reactivestreams.Publisher`里面。|
|Sink|<a name="cancelled"></a>@ref[cancelled](Sink/cancelled.md)|直接取消流|
|Sink|<a name="collection"></a>@ref[collection](Sink/collection.md)|将从流中发出的所有值收集到一个集合中。|
|Sink|<a name="combine"></a>@ref[combine](Sink/combine.md)|使用用户指定的一个策略将多个接收器组合成一个接收器|
|Sink|<a name="completionstagesink"></a>@ref[completionStageSink](Sink/completionStageSink.md)|将元素流动到指定的future接收器，一旦它成功完成。|
|Sink|<a name="fold"></a>@ref[fold](Sink/fold.md)|使用一个函数折叠已发出的元素，每次调用都将获得新元素和前一次折叠调用的结果。|
|Sink|<a name="foreach"></a>@ref[foreach](Sink/foreach.md)|为接收到的每个元素调用一个给定的过程。|
|Sink|<a name="foreachasync"></a>@ref[foreachAsync](Sink/foreachAsync.md)|为接收到的每个元素异步调用一个给定的过程。|
|Sink|<a name="foreachparallel"></a>@ref[foreachParallel](Sink/foreachParallel.md)|类似于`foreach`，但允许通过`parallellism`过程调用来并行发生。|
|Sink|<a name="frommaterializer"></a>@ref[fromMaterializer](Sink/fromMaterializer.md)|将一个`Sink`的创建推迟，直到物化和访问`Materializer`和`Attributes`|
|Sink|<a name="fromsubscriber"></a>@ref[fromSubscriber](Sink/fromSubscriber.md)|与响应流集成，包装一个`org.reactivestreams.Subscriber`作为一个接收器。|
|Sink|<a name="futuresink"></a>@ref[futureSink](Sink/futureSink.md)|将元素流动到指定的future接收器，一旦它成功完成后。|
|Sink|<a name="head"></a>@ref[head](Sink/head.md)|物化到一个 @scala[`Future`]@java[`CompletionStage`] 里面，它将使用第一个到达的值完成，在此之后，流被取消。|
|Sink|<a name="headoption"></a>@ref[headOption](Sink/headOption.md)|物化到一个 @scala[`Future[Option[T]]`] @java[`CompletionStage<Optional<T>>`] 里面，它将使用包裹在 @scala[`Some`]@java[`Optional`] 里面的第一个到达的值完成，或者 @scala[一个`None`]@java[一个空的可选]，如果流在没有发出任何元素的情况下完成。|
|Sink|<a name="ignore"></a>@ref[ignore](Sink/ignore.md)|消耗所有元素但丢弃它们。|
|Sink|<a name="last"></a>@ref[last](Sink/last.md)|物化到一个 @scala[`Future`]@java[`CompletionStage`] 里面，它将在流完成时，使用最后发出的值来完成。|
|Sink|<a name="lastoption"></a>@ref[lastOption](Sink/lastOption.md)|物化一个 @scala[`Future[Option[T]]`]@java[`CompletionStage<Optional<T>>`]，当流完成时，它将使用包裹在一个 @scala[`Some`]@java[`Optional`] 里面的最后一个值完成。|
|Sink|<a name="lazycompletionstagesink"></a>@ref[lazyCompletionStageSink](Sink/lazyCompletionStageSink.md)|延迟一个`Sink`的创建和物化直到第一个元素。|
|Sink|<a name="lazyfuturesink"></a>@ref[lazyFutureSink](Sink/lazyFutureSink.md)|延迟一个`Sink`的创建和物化直到第一个元素。|
|Sink|<a name="lazyinitasync"></a>@ref[lazyInitAsync](Sink/lazyInitAsync.md)|`lazyInitAsync` 在2.6.0中已弃用，请用 `Sink.lazyFutureSink` |
|Sink|<a name="lazysink"></a>@ref[lazySink](Sink/lazySink.md)|延迟一个`Sink`的创建和物化直到第一个元素。|
|Sink|<a name="oncomplete"></a>@ref[onComplete](Sink/onComplete.md)|当流已经完成或失败时调用一个回调。|
|Sink|<a name="prematerialize"></a>@ref[preMaterialize](Sink/preMaterialize.md)|物化这个接收器，立即返回 (1) 它的物化值，(2) 一个新的Sink，它可以消费元素'到'的一个预物化SinK。|
|Sink|<a name="queue"></a>@ref[queue](Sink/queue.md)|物化一个`SinkQueue`，它可以通过接收器'拉'来触发需求。|
|Sink|<a name="reduce"></a>@ref[reduce](Sink/reduce.md)|对传入元素应用归约(reduction)函数，并将结果传递给下一次调用。|
|Sink|<a name="seq"></a>@ref[seq](Sink/seq.md)|收集从流发出的值到集合中。|
|Sink|<a name="setup"></a>@ref[setup](Sink/setup.md)|延迟一个`Sink`的创建，直到物化和访问`ActorMaterializer`和`Attributes`|
|Sink|<a name="takelast"></a>@ref[takeLast](Sink/takeLast.md)|收集从流中发出的最后一个`n`值到集合中。|

## Additional Sink and Source converters

Sources and sinks for integrating with `java.io.InputStream` and `java.io.OutputStream` can be found on
`StreamConverters`. As they are blocking APIs the implementations of these operators are run on a separate
dispatcher configured through the `akka.stream.blocking-io-dispatcher`.

@@@ warning

Be aware that `asInputStream` and `asOutputStream` materialize `InputStream` and `OutputStream` respectively as
blocking API implementation. They will block the thread until data will be available from upstream.
Because of blocking nature these objects cannot be used in `mapMaterializeValue` section as it causes deadlock
of the stream materialization process.
For example, following snippet will fall with timeout exception:

```scala
...
.toMat(StreamConverters.asInputStream().mapMaterializedValue { inputStream =>
        inputStream.read()  // this could block forever
        ...
}).run()
```

@@@


| |Operator|Description|
|--|--|--|
|StreamConverters|<a name="asinputstream"></a>@ref[asInputStream](StreamConverters/asInputStream.md)|Create a sink which materializes into an `InputStream` that can be read to trigger demand through the sink.|
|StreamConverters|<a name="asjavastream"></a>@ref[asJavaStream](StreamConverters/asJavaStream.md)|Create a sink which materializes into Java 8 `Stream` that can be run to trigger demand through the sink.|
|StreamConverters|<a name="asoutputstream"></a>@ref[asOutputStream](StreamConverters/asOutputStream.md)|Create a source that materializes into an `OutputStream`.|
|StreamConverters|<a name="frominputstream"></a>@ref[fromInputStream](StreamConverters/fromInputStream.md)|Create a source that wraps an `InputStream`.|
|StreamConverters|<a name="fromjavastream"></a>@ref[fromJavaStream](StreamConverters/fromJavaStream.md)|Create a source that wraps a Java 8 `Stream`.|
|StreamConverters|<a name="fromoutputstream"></a>@ref[fromOutputStream](StreamConverters/fromOutputStream.md)|Create a sink that wraps an `OutputStream`.|
|StreamConverters|<a name="javacollector"></a>@ref[javaCollector](StreamConverters/javaCollector.md)|Create a sink which materializes into a @scala[`Future`] @java[`CompletionStage`] which will be completed with a result of the Java 8 `Collector` transformation and reduction operations.|
|StreamConverters|<a name="javacollectorparallelunordered"></a>@ref[javaCollectorParallelUnordered](StreamConverters/javaCollectorParallelUnordered.md)|Create a sink which materializes into a @scala[`Future`] @java[`CompletionStage`] which will be completed with a result of the Java 8 `Collector` transformation and reduction operations.|

## File IO Sinks and Sources

Sources and sinks for reading and writing files can be found on `FileIO`.

| |Operator|Description|
|--|--|--|
|FileIO|<a name="fromfile"></a>@ref[fromFile](FileIO/fromFile.md)|发出一个文件的内容。|
|FileIO|<a name="frompath"></a>@ref[fromPath](FileIO/fromPath.md)|从给定路径发出一个文件的内容。|
|FileIO|<a name="tofile"></a>@ref[toFile](FileIO/toFile.md)|创建一个接收器，它将把传入的`ByteString`写到一个给定的文件中。|
|FileIO|<a name="topath"></a>@ref[toPath](FileIO/toPath.md)|创建一个接收器，它将把传入的`ByteString`写入给定的文件路径。|

## Simple operators

These operators can transform the rate of incoming elements since there are operators that emit multiple elements for a
single input (e.g. `mapConcat`) or consume multiple elements before emitting one output (e.g. `filter`).
However, these rate transformations are data-driven, i.e. it is the incoming elements that define how the
rate is affected. This is in contrast with [detached operators](#backpressure-aware-operators) which can change their processing behavior
depending on being backpressured by downstream or not.

| |Operator|Description|
|--|--|--|
|Flow|<a name="asflowwithcontext"></a>@ref[asFlowWithContext](Flow/asFlowWithContext.md)|将一个`Flow`转换为一个`FlowWithContext`，它可以沿着流传播每个元素的上下文。|
|Source/Flow|<a name="collect"></a>@ref[collect](Source-or-Flow/collect.md)|对每个传入元素应用一个偏(partial)函数，如果偏函数是为一个值定义的，则返回的值将向下传递。|
|Source/Flow|<a name="collecttype"></a>@ref[collectType](Source-or-Flow/collectType.md)|通过测试每个元素的类型来转换这个流，当元素通过此处理步骤时，它们是所提供类型的实例。|
|Flow|<a name="completionstageflow"></a>@ref[completionStageFlow](Flow/completionStageFlow.md)|流动元素通过给定的future flow，一旦它成功完成。|
|Source/Flow|<a name="detach"></a>@ref[detach](Source-or-Flow/detach.md)|从下游需求分离上游需求，而不分离流比率。|
|Source/Flow|<a name="drop"></a>@ref[drop](Source-or-Flow/drop.md)|删除`n`个元素，然后向下游传递任何后续元素。|
|Source/Flow|<a name="dropwhile"></a>@ref[dropWhile](Source-or-Flow/dropWhile.md)|删除元素，只要一个谓词函数对元素返回true|
|Source/Flow|<a name="filter"></a>@ref[filter](Source-or-Flow/filter.md)|使用一个谓词过滤传入元素。|
|Source/Flow|<a name="filternot"></a>@ref[filterNot](Source-or-Flow/filterNot.md)|使用一个谓词过滤传入元素。|
|Source/Flow|<a name="fold"></a>@ref[fold](Source-or-Flow/fold.md)|从当前值`zero`开始，然后将当前值和下一个值应用于给定函数。当上游完成时，当前值向下游发出。|
|Source/Flow|<a name="foldasync"></a>@ref[foldAsync](Source-or-Flow/foldAsync.md)|Just like `fold` but receives a function that results in a @scala[`Future`] @java[`CompletionStage`] to the next value.|
|Source/Flow|<a name="frommaterializer"></a>@ref[fromMaterializer](Source-or-Flow/fromMaterializer.md)|Defer the creation of a `Source/Flow` until materialization and access `Materializer` and `Attributes`|
|Flow|<a name="futureflow"></a>@ref[futureFlow](Flow/futureFlow.md)|将元素流过给定的future flow，一旦它成功完成。|
|Source/Flow|<a name="grouped"></a>@ref[grouped](Source-or-Flow/grouped.md)|Accumulate incoming events until the specified number of elements have been accumulated and then pass the collection of elements downstream.|
|Source/Flow|<a name="intersperse"></a>@ref[intersperse](Source-or-Flow/intersperse.md)|Intersperse stream with provided element similar to `List.mkString`.|
|Flow|<a name="lazycompletionstageflow"></a>@ref[lazyCompletionStageFlow](Flow/lazyCompletionStageFlow.md)|将一个`Flow`的创建和物化延迟到第一个元素。|
|Flow|<a name="lazyflow"></a>@ref[lazyFlow](Flow/lazyFlow.md)|Defers creation and materialization of a `Flow` until there is a first element.|
|Flow|<a name="lazyfutureflow"></a>@ref[lazyFutureFlow](Flow/lazyFutureFlow.md)|Defers creation and materialization of a `Flow` until there is a first element.|
|Flow|<a name="lazyinitasync"></a>@ref[lazyInitAsync](Flow/lazyInitAsync.md)|`lazyInitAsync` has been deprecated in 2.6.0 use `Flow.lazyFutureFlow` in combination with `prefixAndTail` instead.|
|Source/Flow|<a name="limit"></a>@ref[limit](Source-or-Flow/limit.md)|Limit number of element from upstream to given `max` number.|
|Source/Flow|<a name="limitweighted"></a>@ref[limitWeighted](Source-or-Flow/limitWeighted.md)|Ensure stream boundedness by evaluating the cost of incoming elements using a cost function.|
|Source/Flow|<a name="log"></a>@ref[log](Source-or-Flow/log.md)|日志记录通过流的元素以及完成和错误。|
|Source/Flow|<a name="map"></a>@ref[map](Source-or-Flow/map.md)|转换流中的每个元素，通过对它调用流中的一个映射函数，并将返回的值传递到下游。|
|Source/Flow|<a name="mapconcat"></a>@ref[mapConcat](Source-or-Flow/mapConcat.md)|将每个元素转换为零个或多个元素，它们会被逐个地传递给下游。|
|Source/Flow|<a name="maperror"></a>@ref[mapError](Source-or-Flow/mapError.md)|While similar to `recover` this operators can be used to transform an error signal to a different one *without* logging it as an error in the process.|
|Source/Flow|<a name="recover"></a>@ref[recover](Source-or-Flow/recover.md)|Allow sending of one last element downstream when a failure has happened upstream.|
|Source/Flow|<a name="recoverwith"></a>@ref[recoverWith](Source-or-Flow/recoverWith.md)|Allow switching to alternative Source when a failure has happened upstream.|
|Source/Flow|<a name="recoverwithretries"></a>@ref[recoverWithRetries](Source-or-Flow/recoverWithRetries.md)|RecoverWithRetries allows to switch to alternative Source on flow failure.|
|Source/Flow|<a name="reduce"></a>@ref[reduce](Source-or-Flow/reduce.md)|开始第一个元素，然后将当前值和下一个值应用于给定函数，当上游完成时，当前值向下游发出。|
|Source/Flow|<a name="scan"></a>@ref[scan](Source-or-Flow/scan.md)|发出它的当前值，它从`zero`开始，然后将当前值和下一个值应用于给定的函数，发出下一个当前值。|
|Source/Flow|<a name="scanasync"></a>@ref[scanAsync](Source-or-Flow/scanAsync.md)|Just like `scan` but receives a function that results in a @scala[`Future`] @java[`CompletionStage`] to the next value.|
|Source/Flow|<a name="setup"></a>@ref[setup](Source-or-Flow/setup.md)|Defer the creation of a `Source/Flow` until materialization and access `Materializer` and `Attributes`|
|Source/Flow|<a name="sliding"></a>@ref[sliding](Source-or-Flow/sliding.md)|Provide a sliding window over the incoming stream and pass the windows as groups of elements downstream.|
|Source/Flow|<a name="statefulmapconcat"></a>@ref[statefulMapConcat](Source-or-Flow/statefulMapConcat.md)|Transform each element into zero or more elements that are individually passed downstream.|
|Source/Flow|<a name="take"></a>@ref[take](Source-or-Flow/take.md)|Pass `n` incoming elements downstream and then complete|
|Source/Flow|<a name="takewhile"></a>@ref[takeWhile](Source-or-Flow/takeWhile.md)|Pass elements downstream as long as a predicate function return true for the element include the element when the predicate first return false and then complete.|
|Source/Flow|<a name="throttle"></a>@ref[throttle](Source-or-Flow/throttle.md)|将吞吐量限制为每个时间单位特定数量的元素，或每个时间单位特定总成本，这时必须提供一个函数来计算每个元素的单个成本。|
|Source/Flow|<a name="watch"></a>@ref[watch](Source-or-Flow/watch.md)|Watch a specific `ActorRef` and signal a failure downstream once the actor terminates.|

## Flow operators composed of Sinks and Sources



| |Operator|Description|
|--|--|--|
|Flow|<a name="fromsinkandsource"></a>@ref[fromSinkAndSource](Flow/fromSinkAndSource.md)|从一个`Sink`和一个`Source`创建一个`Flow`，其中Flow的输入将被发送到`Sink`，而`Flow`的输出将来自`Source`。|
|Flow|<a name="fromsinkandsourcecoupled"></a>@ref[fromSinkAndSourceCoupled](Flow/fromSinkAndSourceCoupled.md)|允许在汇点和源之间创建流时耦合终止(取消、完成和错误)。Allows coupling termination (cancellation, completion, erroring) of Sinks and Sources while creating a Flow between them.|

## Asynchronous operators

These operators encapsulate an asynchronous computation, properly handling backpressure while taking care of the asynchronous
operation at the same time (usually handling the completion of a @scala[`Future`] @java[`CompletionStage`]).

| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="ask"></a>@ref[ask](Source-or-Flow/ask.md)|使用`ask`模式发送请求-应答消息到目标`ref`actor。|
|Source/Flow|<a name="mapasync"></a>@ref[mapAsync](Source-or-Flow/mapAsync.md)|将传入的元素传递给一个函数，它返回一个 @scala[`Future`]@java[`CompletionStage`] 结果。|
|Source/Flow|<a name="mapasyncunordered"></a>@ref[mapAsyncUnordered](Source-or-Flow/mapAsyncUnordered.md)|与`mapAsync`类似，但是 @scala[`Future`]@java[`CompletionStage`] 的结果在到达时向下游传递，而不考虑触发元素的顺序。|

## Timer driven operators

These operators process elements using timers, delaying, dropping or grouping elements for certain time durations.

| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="delay"></a>@ref[delay](Source-or-Flow/delay.md)|使用特定的时长，延迟通过的每个元素。|
|Source/Flow|<a name="dropwithin"></a>@ref[dropWithin](Source-or-Flow/dropWithin.md)|到了已触发超时的时候，就删除元素|
|Source/Flow|<a name="groupedweightedwithin"></a>@ref[groupedWeightedWithin](Source-or-Flow/groupedWeightedWithin.md)|Chunk up this stream into groups of elements received within a time window, or limited by the weight of the elements, whatever happens first.|
|Source/Flow|<a name="groupedwithin"></a>@ref[groupedWithin](Source-or-Flow/groupedWithin.md)|Chunk up this stream into groups of elements received within a time window, or limited by the number of the elements, whatever happens first.|
|Source/Flow|<a name="initialdelay"></a>@ref[initialDelay](Source-or-Flow/initialDelay.md)|Delays the initial element by the specified duration.|
|Source/Flow|<a name="takewithin"></a>@ref[takeWithin](Source-or-Flow/takeWithin.md)|Pass elements downstream within a timeout and then complete.|

## Backpressure aware operators

These operators are aware of the backpressure provided by their downstreams and able to adapt their behavior to that signal.

| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="batch"></a>@ref[batch](Source-or-Flow/batch.md)|Allow for a slower downstream by passing incoming elements and a summary into an aggregate function as long as there is backpressure and a maximum number of batched elements is not yet reached.|
|Source/Flow|<a name="batchweighted"></a>@ref[batchWeighted](Source-or-Flow/batchWeighted.md)|Allow for a slower downstream by passing incoming elements and a summary into an aggregate function as long as there is backpressure and a maximum weight batched elements is not yet reached.|
|Source/Flow|<a name="buffer"></a>@ref[buffer](Source-or-Flow/buffer.md)|通过缓冲`size`个元素来允许一个暂时更快的上游事件。|
|Source/Flow|<a name="conflate"></a>@ref[conflate](Source-or-Flow/conflate.md)|只要存在背压，就可以通过将传入元素和一个摘要传递到一个聚合函数中，来允许一个较慢的下行速度。|
|Source/Flow|<a name="conflatewithseed"></a>@ref[conflateWithSeed](Source-or-Flow/conflateWithSeed.md)|只要存在背压，就可以通过将传入元素和一个摘要传递到一个聚合函数中，来允许一个较慢的下行速度。|
|Source/Flow|<a name="expand"></a>@ref[expand](Source-or-Flow/expand.md)|类似于`extrapolate`，但没有`initial`参数，而且也使用`Iterator`代替原来的元素，允许它被重写和/或过滤。|
|Source/Flow|<a name="extrapolate"></a>@ref[extrapolate](Source-or-Flow/extrapolate.md)|通过将最后发出的元素扩展为一个`Iterator`，允许一个更快的下游。|

## Nesting and flattening operators

These operators either take a stream and turn it into a stream of streams (nesting) or they take a stream that contains
nested streams and turn them into a stream of elements instead (flattening).

See the @ref:[Substreams](../stream-substream.md) page for more detail and code samples.


| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="flatmapconcat"></a>@ref[flatMapConcat](Source-or-Flow/flatMapConcat.md)|Transform each input element into a `Source` whose elements are then flattened into the output stream through concatenation.|
|Source/Flow|<a name="flatmapmerge"></a>@ref[flatMapMerge](Source-or-Flow/flatMapMerge.md)|Transform each input element into a `Source` whose elements are then flattened into the output stream through merging.|
|Source/Flow|<a name="groupby"></a>@ref[groupBy](Source-or-Flow/groupBy.md)|Demultiplex the incoming stream into separate output streams.|
|Source/Flow|<a name="prefixandtail"></a>@ref[prefixAndTail](Source-or-Flow/prefixAndTail.md)|Take up to *n* elements from the stream (less than *n* only if the upstream completes before emitting *n* elements) and returns a pair containing a strict sequence of the taken element and a stream representing the remaining elements.|
|Source/Flow|<a name="splitafter"></a>@ref[splitAfter](Source-or-Flow/splitAfter.md)|End the current substream whenever a predicate returns `true`, starting a new substream for the next element.|
|Source/Flow|<a name="splitwhen"></a>@ref[splitWhen](Source-or-Flow/splitWhen.md)|Split off elements into a new substream whenever a predicate function return `true`.|

## Time aware operators

Those operators operate taking time into consideration.

| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="backpressuretimeout"></a>@ref[backpressureTimeout](Source-or-Flow/backpressureTimeout.md)|如果元素的发射与后续下游需求之间的时间超过了提供的timeout，则流将失败，并包括一个`TimeoutException`。|
|Source/Flow|<a name="completiontimeout"></a>@ref[completionTimeout](Source-or-Flow/completionTimeout.md)|如果流的完成直到提供的timeout还没有发生，则流将失败，并包含一个`TimeoutException`。|
|Source/Flow|<a name="idletimeout"></a>@ref[idleTimeout](Source-or-Flow/idleTimeout.md)|If the time between two processed elements exceeds the provided timeout, the stream is failed with a `TimeoutException`.|
|Source/Flow|<a name="initialtimeout"></a>@ref[initialTimeout](Source-or-Flow/initialTimeout.md)|If the first element has not passed through this operators before the provided timeout, the stream is failed with a `TimeoutException`.|
|Source/Flow|<a name="keepalive"></a>@ref[keepAlive](Source-or-Flow/keepAlive.md)|Injects additional (configured) elements if upstream does not emit for a configured amount of time.|

## Fan-in operators

These operators take multiple streams as their input and provide a single output combining the elements from all of
the inputs in different ways.

| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="concat"></a>@ref[concat](Source-or-Flow/concat.md)|在原始上游完成后，给定源的元素将被发射。|
|Source/Flow|<a name="interleave"></a>@ref[interleave](Source-or-Flow/interleave.md)|Emits a specifiable number of elements from the original source, then from the provided source and repeats.|
|Source/Flow|<a name="merge"></a>@ref[merge](Source-or-Flow/merge.md)|Merge multiple sources.|
|Source/Flow|<a name="mergelatest"></a>@ref[mergeLatest](Source-or-Flow/mergeLatest.md)|Merge multiple sources.|
|Source/Flow|<a name="mergepreferred"></a>@ref[mergePreferred](Source-or-Flow/mergePreferred.md)|Merge multiple sources.|
|Source/Flow|<a name="mergeprioritized"></a>@ref[mergePrioritized](Source-or-Flow/mergePrioritized.md)|Merge multiple sources.|
|Source/Flow|<a name="mergesorted"></a>@ref[mergeSorted](Source-or-Flow/mergeSorted.md)|Merge multiple sources.|
|Source/Flow|<a name="orelse"></a>@ref[orElse](Source-or-Flow/orElse.md)|If the primary source completes without emitting any elements, the elements from the secondary source are emitted.|
|Source/Flow|<a name="prepend"></a>@ref[prepend](Source-or-Flow/prepend.md)|Prepends the given source to the flow, consuming it until completion before the original source is consumed.|
|Source/Flow|<a name="zip"></a>@ref[zip](Source-or-Flow/zip.md)|将来自多个源的每个元素组合到 @scala[元组]@java[*Pair*] 中，并向下游传递 @scala[元组]@java[pairs]。|
|Source/Flow|<a name="zipall"></a>@ref[zipAll](Source-or-Flow/zipAll.md)|Combines all elements from each of multiple sources into @scala[tuples] @java[*Pair*] and passes the @scala[tuples] @java[pairs] downstream.|
|Source/Flow|<a name="ziplatest"></a>@ref[zipLatest](Source-or-Flow/zipLatest.md)|Combines elements from each of multiple sources into @scala[tuples] @java[*Pair*] and passes the @scala[tuples] @java[pairs] downstream, picking always the latest element of each.|
|Source/Flow|<a name="ziplatestwith"></a>@ref[zipLatestWith](Source-or-Flow/zipLatestWith.md)|Combines elements from multiple sources through a `combine` function and passes the returned value downstream, picking always the latest element of each.|
|Source/Flow|<a name="zipwith"></a>@ref[zipWith](Source-or-Flow/zipWith.md)|Combines elements from multiple sources through a `combine` function and passes the returned value downstream.|
|Source/Flow|<a name="zipwithindex"></a>@ref[zipWithIndex](Source-or-Flow/zipWithIndex.md)|Zips elements of current flow with its indices.|

## Fan-out operators

These have one input and multiple outputs. They might route the elements between different outputs, or emit elements on
multiple outputs at the same time.

There is a number of fan-out operators for which currently no 'fluent' is API available. To use those you will have to use the @ref[Graph DSL](../stream-graphs.md#constructing-graphs).


| |Operator|Description|
|--|--|--|
| |<a name="balance"></a>@ref[Balance](Balance.md)|Fan-out the stream to several streams.|
| |<a name="broadcast"></a>@ref[Broadcast](Broadcast.md)|Emit each incoming element each of `n` outputs.|
| |<a name="partition"></a>@ref[Partition](Partition.md)|Fan-out the stream to several streams.|
| |<a name="unzip"></a>@ref[Unzip](Unzip.md)|Takes a stream of two element tuples and unzips the two elements ino two different downstreams.|
| |<a name="unzipwith"></a>@ref[UnzipWith](UnzipWith.md)|Splits each element of input into multiple downstreams using a function|
|Source/Flow|<a name="alsoto"></a>@ref[alsoTo](Source-or-Flow/alsoTo.md)|将给定的`Sink`附加到这个`Flow`，这意味着通过这个`Flow`的元素也将被发送到`Sink`。|
|Source/Flow|<a name="divertto"></a>@ref[divertTo](Source-or-Flow/divertTo.md)|根据应用于元素的谓词函数，每个上游元素要么被转移到给定的接收器，要么被转移到下游消费者。|
|Source/Flow|<a name="wiretap"></a>@ref[wireTap](Source-or-Flow/wireTap.md)|Attaches the given `Sink` to this `Flow` as a wire tap, meaning that elements that pass through will also be sent to the wire-tap `Sink`, without the latter affecting the mainline flow.|

## Watching status operators



| |Operator|Description|
|--|--|--|
|Source/Flow|<a name="monitor"></a>@ref[monitor](Source-or-Flow/monitor.md)|Materializes to a `FlowMonitor` that monitors messages flowing through or completion of the operators.|
|Source/Flow|<a name="watchtermination"></a>@ref[watchTermination](Source-or-Flow/watchTermination.md)|Materializes to a @scala[`Future`] @java[`CompletionStage`] that will be completed with Done or failed depending whether the upstream of the operators has been completed or failed.|

## Actor interop operators

Operators meant for inter-operating between Akka Streams and Actors:


| |Operator|Description|
|--|--|--|
|ActorSource|<a name="actorref"></a>@ref[actorRef](ActorSource/actorRef.md)|Materialize an @java[`ActorRef<T>`]@scala[`ActorRef[T]`]; sending messages to it will emit them on the stream only if they are of the same type as the stream.|
|ActorSink|<a name="actorref"></a>@ref[actorRef](ActorSink/actorRef.md)|Sends the elements of the stream to the given @java[`ActorRef<T>`]@scala[`ActorRef[T]`], without considering backpressure.|
|ActorSource|<a name="actorrefwithbackpressure"></a>@ref[actorRefWithBackpressure](ActorSource/actorRefWithBackpressure.md)|Materialize an @java[`ActorRef<T>`]@scala[`ActorRef[T]`]; sending messages to it will emit them on the stream. The source acknowledges reception after emitting a message, to provide back pressure from the source.|
|ActorSink|<a name="actorrefwithbackpressure"></a>@ref[actorRefWithBackpressure](ActorSink/actorRefWithBackpressure.md)|Sends the elements of the stream to the given @java[`ActorRef<T>`]@scala[`ActorRef[T]`] with backpressure, to be able to signal demand when the actor is ready to receive more elements.|
|ActorFlow|<a name="ask"></a>@ref[ask](ActorFlow/ask.md)|Use the `AskPattern` to send each element as an `ask` to the target actor, and expect a reply back that will be sent further downstream.|

## Error handling

For more background see the @ref[Error Handling in Streams](../stream-error.md) section.

| |Operator|Description|
|--|--|--|
|RestartSource|<a name="onfailureswithbackoff"></a>@ref[onFailuresWithBackoff](RestartSource/onFailuresWithBackoff.md)|Wrap the given @apidoc[Source] with a @apidoc[Source] that will restart it when it fails using an exponential backoff.|
|RestartFlow|<a name="onfailureswithbackoff"></a>@ref[onFailuresWithBackoff](RestartFlow/onFailuresWithBackoff.md)|Wrap the given @apidoc[Flow] with a @apidoc[Flow] that will restart it when it fails using an exponential backoff. Notice that this @apidoc[Flow] will not restart on completion of the wrapped flow.|
|RestartSource|<a name="withbackoff"></a>@ref[withBackoff](RestartSource/withBackoff.md)|Wrap the given @apidoc[Source] with a @apidoc[Source] that will restart it when it fails or complete using an exponential backoff.|
|RestartFlow|<a name="withbackoff"></a>@ref[withBackoff](RestartFlow/withBackoff.md)|Wrap the given @apidoc[Flow] with a @apidoc[Flow] that will restart it when it fails or complete using an exponential backoff.|
|RestartSink|<a name="withbackoff"></a>@ref[withBackoff](RestartSink/withBackoff.md)|Wrap the given @apidoc[Sink] with a @apidoc[Sink] that will restart it when it fails or complete using an exponential backoff.|
|RetryFlow|<a name="withbackoff"></a>@ref[withBackoff](RetryFlow/withBackoff.md)|Wrap the given @apidoc[Flow] and retry individual elements in that stream with an exponential backoff. A decider function tests every emitted element and can return a new element to be sent to the wrapped flow for another try.|
|RetryFlow|<a name="withbackoffandcontext"></a>@ref[withBackoffAndContext](RetryFlow/withBackoffAndContext.md)|Wrap the given @apidoc[FlowWithContext] and retry individual elements in that stream with an exponential backoff. A decider function tests every emitted element and can return a new element to be sent to the wrapped flow for another try.|

@@@ index

* [combine](Source/combine.md)
* [asSourceWithContext](Source/asSourceWithContext.md)
* [fromPublisher](Source/fromPublisher.md)
* [fromIterator](Source/fromIterator.md)
* [cycle](Source/cycle.md)
* [fromMaterializer](Source-or-Flow/fromMaterializer.md)
* [setup](Source-or-Flow/setup.md)
* [fromFuture](Source/fromFuture.md)
* [fromCompletionStage](Source/fromCompletionStage.md)
* [fromFutureSource](Source/fromFutureSource.md)
* [fromSourceCompletionStage](Source/fromSourceCompletionStage.md)
* [tick](Source/tick.md)
* [single](Source/single.md)
* [repeat](Source/repeat.md)
* [unfold](Source/unfold.md)
* [unfoldAsync](Source/unfoldAsync.md)
* [empty](Source/empty.md)
* [maybe](Source/maybe.md)
* [failed](Source/failed.md)
* [lazily](Source/lazily.md)
* [lazilyAsync](Source/lazilyAsync.md)
* [future](Source/future.md)
* [completionStage](Source/completionStage.md)
* [futureSource](Source/futureSource.md)
* [lazySingle](Source/lazySingle.md)
* [lazyFuture](Source/lazyFuture.md)
* [lazySource](Source/lazySource.md)
* [lazyFutureSource](Source/lazyFutureSource.md)
* [asSubscriber](Source/asSubscriber.md)
* [actorRef](Source/actorRef.md)
* [actorRefWithBackpressure](Source/actorRefWithBackpressure.md)
* [zipN](Source/zipN.md)
* [zipWithN](Source/zipWithN.md)
* [queue](Source/queue.md)
* [unfoldResource](Source/unfoldResource.md)
* [unfoldResourceAsync](Source/unfoldResourceAsync.md)
* [@scala[apply]@java[from]](Source/from.md)
* [range](Source/range.md)
* [completionStageSource](Source/completionStageSource.md)
* [lazyCompletionStage](Source/lazyCompletionStage.md)
* [lazyCompletionStageSource](Source/lazyCompletionStageSource.md)
* [concat](Source-or-Flow/concat.md)
* [prepend](Source-or-Flow/prepend.md)
* [orElse](Source-or-Flow/orElse.md)
* [alsoTo](Source-or-Flow/alsoTo.md)
* [divertTo](Source-or-Flow/divertTo.md)
* [wireTap](Source-or-Flow/wireTap.md)
* [interleave](Source-or-Flow/interleave.md)
* [merge](Source-or-Flow/merge.md)
* [mergeLatest](Source-or-Flow/mergeLatest.md)
* [mergePreferred](Source-or-Flow/mergePreferred.md)
* [mergePrioritized](Source-or-Flow/mergePrioritized.md)
* [mergeSorted](Source-or-Flow/mergeSorted.md)
* [zip](Source-or-Flow/zip.md)
* [zipAll](Source-or-Flow/zipAll.md)
* [zipLatest](Source-or-Flow/zipLatest.md)
* [zipWith](Source-or-Flow/zipWith.md)
* [zipLatestWith](Source-or-Flow/zipLatestWith.md)
* [zipWithIndex](Source-or-Flow/zipWithIndex.md)
* [map](Source-or-Flow/map.md)
* [recover](Source-or-Flow/recover.md)
* [mapError](Source-or-Flow/mapError.md)
* [recoverWith](Source-or-Flow/recoverWith.md)
* [recoverWithRetries](Source-or-Flow/recoverWithRetries.md)
* [mapConcat](Source-or-Flow/mapConcat.md)
* [statefulMapConcat](Source-or-Flow/statefulMapConcat.md)
* [mapAsync](Source-or-Flow/mapAsync.md)
* [mapAsyncUnordered](Source-or-Flow/mapAsyncUnordered.md)
* [ask](Source-or-Flow/ask.md)
* [watch](Source-or-Flow/watch.md)
* [filter](Source-or-Flow/filter.md)
* [filterNot](Source-or-Flow/filterNot.md)
* [collect](Source-or-Flow/collect.md)
* [collectType](Source-or-Flow/collectType.md)
* [grouped](Source-or-Flow/grouped.md)
* [limit](Source-or-Flow/limit.md)
* [limitWeighted](Source-or-Flow/limitWeighted.md)
* [sliding](Source-or-Flow/sliding.md)
* [scan](Source-or-Flow/scan.md)
* [scanAsync](Source-or-Flow/scanAsync.md)
* [fold](Source-or-Flow/fold.md)
* [foldAsync](Source-or-Flow/foldAsync.md)
* [reduce](Source-or-Flow/reduce.md)
* [intersperse](Source-or-Flow/intersperse.md)
* [groupedWithin](Source-or-Flow/groupedWithin.md)
* [groupedWeightedWithin](Source-or-Flow/groupedWeightedWithin.md)
* [delay](Source-or-Flow/delay.md)
* [drop](Source-or-Flow/drop.md)
* [dropWithin](Source-or-Flow/dropWithin.md)
* [takeWhile](Source-or-Flow/takeWhile.md)
* [dropWhile](Source-or-Flow/dropWhile.md)
* [take](Source-or-Flow/take.md)
* [takeWithin](Source-or-Flow/takeWithin.md)
* [conflateWithSeed](Source-or-Flow/conflateWithSeed.md)
* [conflate](Source-or-Flow/conflate.md)
* [batch](Source-or-Flow/batch.md)
* [batchWeighted](Source-or-Flow/batchWeighted.md)
* [expand](Source-or-Flow/expand.md)
* [extrapolate](Source-or-Flow/extrapolate.md)
* [buffer](Source-or-Flow/buffer.md)
* [prefixAndTail](Source-or-Flow/prefixAndTail.md)
* [groupBy](Source-or-Flow/groupBy.md)
* [splitWhen](Source-or-Flow/splitWhen.md)
* [splitAfter](Source-or-Flow/splitAfter.md)
* [flatMapConcat](Source-or-Flow/flatMapConcat.md)
* [flatMapMerge](Source-or-Flow/flatMapMerge.md)
* [initialTimeout](Source-or-Flow/initialTimeout.md)
* [completionTimeout](Source-or-Flow/completionTimeout.md)
* [idleTimeout](Source-or-Flow/idleTimeout.md)
* [backpressureTimeout](Source-or-Flow/backpressureTimeout.md)
* [keepAlive](Source-or-Flow/keepAlive.md)
* [throttle](Source-or-Flow/throttle.md)
* [detach](Source-or-Flow/detach.md)
* [watchTermination](Source-or-Flow/watchTermination.md)
* [monitor](Source-or-Flow/monitor.md)
* [initialDelay](Source-or-Flow/initialDelay.md)
* [log](Source-or-Flow/log.md)
* [asFlowWithContext](Flow/asFlowWithContext.md)
* [fromSinkAndSource](Flow/fromSinkAndSource.md)
* [fromSinkAndSourceCoupled](Flow/fromSinkAndSourceCoupled.md)
* [lazyInitAsync](Flow/lazyInitAsync.md)
* [futureFlow](Flow/futureFlow.md)
* [lazyFlow](Flow/lazyFlow.md)
* [lazyFutureFlow](Flow/lazyFutureFlow.md)
* [completionStageFlow](Flow/completionStageFlow.md)
* [lazyCompletionStageFlow](Flow/lazyCompletionStageFlow.md)
* [preMaterialize](Sink/preMaterialize.md)
* [fromMaterializer](Sink/fromMaterializer.md)
* [setup](Sink/setup.md)
* [fromSubscriber](Sink/fromSubscriber.md)
* [cancelled](Sink/cancelled.md)
* [head](Sink/head.md)
* [headOption](Sink/headOption.md)
* [last](Sink/last.md)
* [lastOption](Sink/lastOption.md)
* [takeLast](Sink/takeLast.md)
* [seq](Sink/seq.md)
* [collection](Sink/collection.md)
* [asPublisher](Sink/asPublisher.md)
* [ignore](Sink/ignore.md)
* [foreach](Sink/foreach.md)
* [foreachAsync](Sink/foreachAsync.md)
* [combine](Sink/combine.md)
* [foreachParallel](Sink/foreachParallel.md)
* [fold](Sink/fold.md)
* [reduce](Sink/reduce.md)
* [onComplete](Sink/onComplete.md)
* [actorRef](Sink/actorRef.md)
* [actorRefWithBackpressure](Sink/actorRefWithBackpressure.md)
* [queue](Sink/queue.md)
* [lazyInitAsync](Sink/lazyInitAsync.md)
* [futureSink](Sink/futureSink.md)
* [lazySink](Sink/lazySink.md)
* [lazyFutureSink](Sink/lazyFutureSink.md)
* [completionStageSink](Sink/completionStageSink.md)
* [lazyCompletionStageSink](Sink/lazyCompletionStageSink.md)
* [fromInputStream](StreamConverters/fromInputStream.md)
* [asOutputStream](StreamConverters/asOutputStream.md)
* [fromOutputStream](StreamConverters/fromOutputStream.md)
* [asInputStream](StreamConverters/asInputStream.md)
* [javaCollector](StreamConverters/javaCollector.md)
* [javaCollectorParallelUnordered](StreamConverters/javaCollectorParallelUnordered.md)
* [asJavaStream](StreamConverters/asJavaStream.md)
* [fromJavaStream](StreamConverters/fromJavaStream.md)
* [fromFile](FileIO/fromFile.md)
* [fromPath](FileIO/fromPath.md)
* [toFile](FileIO/toFile.md)
* [toPath](FileIO/toPath.md)
* [withBackoff](RestartSource/withBackoff.md)
* [onFailuresWithBackoff](RestartSource/onFailuresWithBackoff.md)
* [withBackoff](RestartFlow/withBackoff.md)
* [onFailuresWithBackoff](RestartFlow/onFailuresWithBackoff.md)
* [withBackoff](RestartSink/withBackoff.md)
* [withBackoff](RetryFlow/withBackoff.md)
* [withBackoffAndContext](RetryFlow/withBackoffAndContext.md)
* [actorRef](ActorSource/actorRef.md)
* [actorRefWithBackpressure](ActorSource/actorRefWithBackpressure.md)
* [ask](ActorFlow/ask.md)
* [actorRef](ActorSink/actorRef.md)
* [actorRefWithBackpressure](ActorSink/actorRefWithBackpressure.md)
* [Partition](Partition.md)
* [Broadcast](Broadcast.md)
* [Balance](Balance.md)
* [Unzip](Unzip.md)
* [UnzipWith](UnzipWith.md)

@@@
